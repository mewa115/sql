As we saw in the video, PostgreSQL has a system database called INFORMATION_SCHEMA that allows us to extract information about objects, including tables, in our database.
In this exercise we will look at how to query the tables table of the INFORMATION_SCHEMA database to discover information about tables in the DVD Rentals database 
including the name, type, schema, and catalog of all tables and views and then how to use the results to get additional information about columns in our tables.
Select all columns from the INFORMATION_SCHEMA.TABLES system database. Limit results that have a public table_schema.

 -- Select all columns from the TABLES system database
 SELECT * 
 FROM INFORMATION_SCHEMA.tables
 -- Filter by schema
 WHERE table_schema = 'public';
 
 
 
 Select all columns from the INFORMATION_SCHEMA.COLUMNS system database. Limit by table_name to actor
 
  -- Select all columns from the COLUMNS system database
 SELECT * 
 FROM INFORMATION_SCHEMA.COLUMNS
 WHERE table_name = 'actor';
 

Determining data types
The columns table of the INFORMATION_SCHEMA database also allows us to extract information about the data types of columns in a table. 
We can extract information like the character or string length of a CHAR or VARCHAR column or the precision of a DECIMAL or NUMERIC floating point type.
Using the techniques you learned in the lesson, let's explore the customer table of our DVD Rental database.
Select the column name and data type from the INFORMATION_SCHEMA.COLUMNS system database.
Limit results to only include the customer table.


-- Get the column name and data type
SELECT *
-- From the system database information schema
FROM INFORMATION_SCHEMA.COLUMNS 
-- For the customer table
WHERE table_name = 'customer';


Interval data types
INTERVAL data types provide you with a very useful tool for performing arithmetic on date and time data types. 
For example, let's say our rental policy requires a DVD to be returned within 3 days. 
We can calculate the expected_return_date for a given DVD rental by adding an INTERVAL of 3 days to the rental_date from the rental table. 
We can then compare this result to the actual return_date to determine if the DVD was returned late.
Select the rental date and return date from the rental table.
Add an INTERVAL of 3 days to the rental_date to calculate the expected return date`.

SELECT
 	-- Select the rental and return dates
	rental_date,
	return_date,
	-- Calculate the expected_return_date
	rental_date + interval '3 days' AS expected_return_date
FROM rental;


Accessing data in an ARRAY
In our DVD Rentals database, the film table contains an ARRAY for special_features which has a type of TEXT[]. 
Much like any ARRAY data type in PostgreSQL, a TEXT[] array can store an array of TEXT values.
This comes in handy when you want to store things like phone numbers or email addresses as we saw in the lesson.
Let's take a look at the special_features column and also practice accessing data in the ARRAY.
Select the title and special features from the film table and compare the results between the two columns.

-- Select the title and special features column 
SELECT 
  title, 
  special_features  
FROM film;


Select all films that have a special feature Trailers by filtering on the first index of the special_features ARRAY.
-- Select the title and special features column 
SELECT 
  title, 
  special_features 
FROM film
-- Use the array index of the special_features column
WHERE special_features[1] = 'Trailers';



Now let's select all films that have Deleted Scenes in the second index of the special_features ARRAY.
-- Select the title and special features column 
SELECT 
  title, 
  special_features 
FROM film
-- Use the array index of the special_features column
WHERE special_features[2] = 'Deleted Scenes';





Searching an ARRAY with ANY
As we saw in the video, PostgreSQL also provides the ability to filter results by searching for values in an ARRAY. 
The ANY function allows you to search for a value in any index position of an ARRAY. Here's an example.
WHERE 'search text' = ANY(array_name)
When using the ANY function, the value you are filtering on appears on the left side of the equation with the name of the ARRAY column as the parameter in the ANY function.
Match 'Trailers' in any index of the special_features ARRAY regardless of position.

SELECT
  title, 
  special_features 
FROM film 
-- Modify the query to use the ANY function 
WHERE 'Trailers' = ANY (special_features);




Searching an ARRAY with @>
The contains operator @> operator is alternative syntax to the ANY function and matches data in an ARRAY using the following syntax.
WHERE array_name @> ARRAY['search text'] :: type[]
So let's practice using this operator in the exercise.
Use the contains operator to match the text Deleted Scenes in the special_features column.

SELECT 
  title, 
  special_features 
FROM film 
-- Filter where special_features contains 'Deleted Scenes'
WHERE special_features @> ARRAY['Deleted Scenes'];





Adding and subtracting date and time values
In this exercise, you will calculate the actual number of days rented as well as the true expected_return_date 
by using the rental_duration column from the film table along with the familiar rental_date from the rental table.
This will require that you dust off the skills you learned from prior courses on how to join two or more tables together. 
To select columns from both the film and rental tables in a single query, we'll need to use the inventory table 
to join these two tables together since there is no explicit relationship between them. Let's give it a try!
Subtract the rental_date from the return_date to calculate the number of days_rented.

SELECT f.title, f.rental_duration,
    -- Calculate the number of days rented
    r.return_date - r.rental_date AS days_rented
FROM film AS f
     INNER JOIN inventory AS i ON f.film_id = i.film_id
     INNER JOIN rental AS r ON i.inventory_id = r.inventory_id
ORDER BY f.title;


Now use the AGE() function to calculate the days_rented.
SELECT f.title, f.rental_duration,
    -- Calculate the number of days rented
	age(return_date, rental_date) AS days_rented
FROM film AS f
	INNER JOIN inventory AS i ON f.film_id = i.film_id
	INNER JOIN rental AS r ON i.inventory_id = r.inventory_id
ORDER BY f.title;


INTERVAL arithmetic
If you were running a real DVD Rental store, there would be times when you would need to determine what film titles were currently out for rental with customers.
In the previous exercise, we saw that some of the records in the results had a NULL value for the return_date. This is because the rental was still outstanding.
Each rental in the film table has an associated rental_duration column which represents the number of days that a DVD can be rented by a customer before it is considered late. 
In this example, you will exclude films that have a NULL value for the return_date and also convert the rental_duration to an INTERVAL type. 
Here's a reminder of one method for performing this conversion.
SELECT INTERVAL '1' day * timestamp '2019-04-10 12:34:56'
Convert rental_duration by multiplying it with a 1 day INTERVAL
Subtract the rental_date from the return_date to calculate the number of days_rented.
Exclude rentals with a NULL value for return_date.

SELECT
	f.title,
 	-- Convert the rental_duration to an interval
    INTERVAL '1' day * rental_duration,
 	-- Calculate the days rented as we did previously
    r.return_date - r.rental_date AS days_rented
FROM film AS f
    INNER JOIN inventory AS i ON f.film_id = i.film_id
    INNER JOIN rental AS r ON i.inventory_id = r.inventory_id
-- Filter the query to exclude outstanding rentals
WHERE r.return_date is not null
ORDER BY f.title;



Calculating the expected return date
So now that you've practiced how to add and subtract timestamps and perform relative calculations using intervals, 
let's use those new skills to calculate the actual expected return date of a specific rental. As you've seen in previous exercises,
the rental_duration is the number of days allowed for a rental before it's considered late. To calculate the expected_return_date 
you will want to use the rental_duration and add it to the rental_date.
Convert rental_duration by multiplying it with a 1-day INTERVAL.
Add it to the rental date.

SELECT
    f.title,
	r.rental_date,
    f.rental_duration,
    -- Add the rental duration to the rental date
    interval '1' day * f.rental_duration + r.rental_date AS expected_return_date,
    r.return_date
FROM film AS f
    INNER JOIN inventory AS i ON f.film_id = i.film_id
    INNER JOIN rental AS r ON i.inventory_id = r.inventory_id
ORDER BY f.title;





Current timestamp functions
Use the console to explore the NOW(), CURRENT_TIMESTAMP, CURRENT_DATE and CURRENT_TIME functions and their outputs to determine which of the following is NOT correct?

select now();
select CURRENT_TIMESTAMP;
select current_date;
select current_time



Now, let's use the CAST() function to eliminate the timezone from the current timestamp.
--Select the current timestamp without a timezone
SELECT cast( NOW() AS timestamp)


Finally, let's select the current date.
Use CAST() to retrieve the same result from the NOW() function.

SELECT 
-- Select the current date
current_date,
-- CAST the result of the NOW() function to a date
cast(now() AS date)
